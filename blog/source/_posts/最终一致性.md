title: 使用最终一致性解决分布式事务

date: 2016-09-06

categories: [分布式事务&一致性] 

---
> 分布式事务可以用可靠消息事件达到最终一致性的方式解决

 <!--more-->
 
如图所示

![最终一致性.png](https://raw.githubusercontent.com/uguesswhoami/pictures/master/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7.png)

* 微服务1操作数据库A
* 微服务1发送消息到消息队列
* 消息队列持久化消息
* 微服务2接收消息处理并操作数据库B

`将分布式事务通过消息队列解耦成两个本地事务操作`

`可能出现的问题：`
* 微服务1操作数据库A异常
* 微服务1操作数据库A正常，但发送消息失败，发送消息失败又分为两种：
    * 消息队列并没有持久化消息就失败
    * 消息队列已经持久化消息但因网络异常等原因失败
* 微服务2接收到消息，但是处理消息失败，即操作数据库B失败

`解决：`
* 微服务1操作数据库A的同时操作本地事件表M。 微服务1操作数据库A，并插入本地事件表（两者在同一个事务中），并发送消息，发送消息成功则删除本地事件表中该事件，保证微服务1的消息可靠性。伪代码如下：

`消息发送端：`
```
begin transaction
    insert tbl_A;
    insert tbl_event_M;
end transaction
    if('send message' == success){
        delete tbl_event_M;
    }
```

* 同时在微服务2侧添加本地事件表N，目前大多数消息队列比如Kafka可以保证消息至少到达一次（at least once），所以消息是一定会到达微服务2侧，但是微服务2侧是否仅正确处理一次，这个就需要本地事件表N来保证，首先在消息到达后，查询事件表N是否处理过该事件，如果处理过，直接返回结果，确保消息处理的幂等性，如果没有处理过，则插入该消息事件到消息表N中，并操作数据库B，处理成功删除事件表中该事件标记（与操作数据库B在同一事务中）。伪代码如下：

`消息接收端：`
```
peek message;
begin transaction
    select count(*) as count from tbl_event_N;
    if(count == 0){
        insert tbl_A;
        insert tbl_event_N;
    }
end transaction
queue ack;
```

`复盘如下：`
* 假设微服务1操作数据库A失败，则回滚该操作，此时本地事件表上并没有该事件，相安无事；
* 假设微服务1操作数据库A成功，此时插入事件表并发送消息事件，若消息队列在持久化消息之前失败，此时事件表中会记录该事件，定时处理该表中数据；
* 假设微服务1操作数据库A成功，此时插入事件表并发送消息事件，若消息队列在持久化消息之后失败，此时事件表中同样会记录该事件，定时处理该表中数据，此时可能会造成微服务2重复处理消息，因此微服务2要做好幂等处理；
* 微服务1操作数据库A成功，且发送消息成功，此时删除事件表中该消息事件记录，若删除该消息事件记录失败，则当定时处理该表中数据时还是会发送消息然后删除记录，此时又要保证微服务2的幂等控制。

`其中消息的必达性由消息队列保证`

> 既然是最终一致性，那在达到最终一致性的窗口期就会有短暂的不一致，这个取决于事件消息的数量，消息队列处理消息的性能及接收消息端处理消息的性能等。适用于可以容忍短暂不一致的场景。